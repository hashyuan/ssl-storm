// Generated by CoffeeScript 1.9.3
(function() {
  var Promise, PutConfig, Start, Stop, Update, Valid, Validate, Validator, assert, async, getPromise, needle, schema;

  Valid = require('jsonschema').Validator;

  Validator = new Valid;

  assert = require('assert');

  Promise = require('bluebird');

  async = require('async');

  needle = Promise.promisifyAll(require('needle'));

  schema = {
    name: "sslfilter",
    type: "object",
    required: true,
    additionalProperties: false,
    properties: {
      "SSL_CERT_INSPECTION": {
        "type": "boolean",
        "required": true
      },
      "SSL_DOMAIN_FILTERING": {
        "type": "boolean",
        "required": true
      },
      "SSL_FILTER_SCANDOMAIN_CERT": {
        "type": "boolean",
        "required": true
      },
      "SSL_FILTER_RESTRICT_SSL_CERT": {
        "type": "boolean",
        "required": true
      },
      "SSL_FILTER_WEBWARNING": {
        "type": "boolean",
        "required": true
      },
      "SSL_FFPROXY_DIR": {
        "type": "string",
        "required": false
      },
      "SSL_CONTENT_INSPECTION": {
        "type": "boolean",
        "required": true
      },
      "SSL_BYPASS_DATA_INSPECTION": {
        "type": "boolean",
        "required": true
      },
      "SSL_BYPASS_INCLUDE_DOMAIN": {
        "type": "boolean",
        "required": true
      },
      "SSL_INSPECT_CACHE": {
        "type": "boolean",
        "required": false
      },
      "SSL_INSPECT_CACHE_MAX_ENTRIES": {
        "type": "number",
        "required": false
      },
      "SSL_INSPECT_CACHE_PERSIST": {
        "type": "boolean",
        "required": false
      },
      "SSL_INSPECT_CACHE_STORE": {
        "type": "string",
        "required": false
      },
      "SSL_INSPECT_CABUNDLE": {
        "type": "object",
        properties: {
          "filename": {
            "type": "string",
            "required": false
          },
          "encoding": {
            "type": "string",
            "required": false
          },
          "data": {
            "type": "string",
            "required": false
          }
        }
      },
      "SSL_INSPECT_CACERT": {
        "type": "object",
        properties: {
          "filename": {
            "type": "string",
            "required": false
          },
          "encoding": {
            "type": "string",
            "required": false
          },
          "data": {
            "type": "string",
            "required": false
          }
        }
      },
      "SSL_INSPECT_CAKEY": {
        "type": "object",
        properties: {
          "filename": {
            "type": "string",
            "required": false
          },
          "encoding": {
            "type": "string",
            "required": false
          },
          "data": {
            "type": "string",
            "required": false
          }
        }
      },
      "SSL_CATEGORY_POLICY": {
        "type": "object",
        properties: {
          "filename": {
            "type": "string",
            "required": false
          },
          "encoding": {
            "type": "string",
            "required": false
          },
          "data": {
            "type": "string",
            "required": false
          }
        }
      },
      "SSL_CATEGORY_USER": {
        "type": "object",
        properties: {
          "filename": {
            "type": "string",
            "required": false
          },
          "encoding": {
            "type": "string",
            "required": false
          },
          "data": {
            "type": "string",
            "required": false
          }
        }
      }
    }
  };

  getPromise = function() {
    return new Promise(function(resolve, reject) {
      return resolve();
    });
  };

  Validate = function(config) {
    var options, policyConfig, ref, res;
    policyConfig = {};
    if (config.enable && config.coreConfig) {
      options = {};
      options.propertyName = 'sslfilter';
      res = Validator.validate(config.coreConfig, schema, options);
      if ((ref = res.errors) != null ? ref.length : void 0) {
        throw new Error("sslfilter.Validate ", res);
      }
    }
  };

  PutConfig = function(baseUrl, config) {
    return needle.getAsync(baseUrl + "/corenova", {
      json: true
    }).then((function(_this) {
      return function(resp) {
        var corenovas;
        if (resp[0].statusCode !== 200) {
          throw new Error('invalidStatusCode');
        }
        corenovas = resp[0].body;
        return corenovas[0].id;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this)).then((function(_this) {
      return function(id) {
        return needle.putAsync(baseUrl + ("/corenova/" + id + "/transform/include"), config, {
          json: true
        }).then(function(resp) {
          if (resp[0].statusCode !== 200) {
            throw new Error('invalidStatusCode');
          }
          return {
            name: "sslfilter",
            id: id
          };
        })["catch"](function(err) {
          throw err;
        });
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return resp;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Start = function(context) {
    var config, configObj, ref, ref1;
    if (!(context.bInstalledPackages && context.service)) {
      throw new Error('sslfilter-storm.Start: missingParams');
    }
    if (((ref = context.instances) != null ? ref.length : void 0) === 1) {
      return context;
    }
    if (context.instances == null) {
      context.instances = [];
    }
    configObj = (ref1 = context.service.factoryConfig) != null ? ref1.config : void 0;
    config = configObj[context.service.name];
    return getPromise().then((function(_this) {
      return function(resp) {
        if (config.enable && config.coreConfig) {
          PutConfig(context.baseUrl, config.coreConfig).then(function(resp) {
            return context.instances.push(resp);
          });
        }
        return context;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Update = function(context) {
    var config;
    if (!(context.instances && context.policyConfig)) {
      throw new Error({
        name: 'sslfilter-storm.Update: missingParams'
      });
    }
    config = context.policyConfig[context.service.name];
    return getPromise().then((function(_this) {
      return function(resp) {
        if (config.enable && config.coreConfig) {
          return PutConfig(context.baseUrl, config.coreConfig);
        }
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return resp;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  Stop = function(context) {
    if (!context.instances) {
      throw new Error({
        name: 'sslfilter-storm.Update: missingParams'
      });
    }
    return getPromise().then((function(_this) {
      return function(resp) {
        var config, configObj, ref;
        configObj = (ref = context.service.factoryConfig) != null ? ref.config : void 0;
        config = configObj[context.service.name];
        return PutConfig(context.baseUrl, config.coreConfig);
      };
    })(this)).then((function(_this) {
      return function(resp) {
        return resp;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        throw err;
      };
    })(this));
  };

  module.exports.Context = {
    start: Start,
    stop: Stop,
    update: Update,
    validate: Validate
  };

}).call(this);
